import { test, expect } from "@playwright/test";

/**
 * Playwright tests for ops-translate HTML report interactive features.
 *
 * Tests the static HTML report generated by ops-translate, including:
 * - Card-based filtering by classification level (SUPPORTED/PARTIAL/BLOCKED/MANUAL)
 * - Filter indicator visibility
 * - Gap item filtering
 * - Clear filter functionality
 *
 * Report structure:
 *   examples/sample-report/
 *     index.html
 *     assets/
 *       app.js
 *       styles.css
 */
test.describe("ops-translate HTML report demo", () => {
  test("can load report and verify basic structure", async ({ page }) => {
    await page.goto("/index.html", { waitUntil: "domcontentloaded" });

    // Verify report loads with main heading
    await expect(
      page.getByRole("heading", { name: /Translation Report|Gap Analysis Report/i })
    ).toBeVisible();

    // Verify summary cards are present
    const cards = page.locator(".card[data-filter]");
    await expect(cards).toHaveCount(4); // SUPPORTED, PARTIAL, BLOCKED, MANUAL

    // Filter indicator should start hidden
    const filterIndicator = page.locator("#filter-indicator");
    await expect(filterIndicator).toHaveClass(/hidden/);
  });

  test("can filter gaps by BLOCKED classification", async ({ page }) => {
    await page.goto("/index.html", { waitUntil: "domcontentloaded" });

    // Filter indicator should start hidden
    const filterIndicator = page.locator("#filter-indicator");
    await expect(filterIndicator).toHaveClass(/hidden/);

    // Click the "BLOCKED" summary card to filter (now Expert-Guided)
    const blockedCard = page.locator('.card[data-filter="BLOCKED"]');
    await blockedCard.click();

    // Filter indicator should now be visible
    await expect(filterIndicator).not.toHaveClass(/hidden/);
    await expect(page.locator("#filter-name")).toContainText(/BLOCKED|Expert-Guided/i);

    // Only BLOCKED gap items should remain visible
    const blockedGapItems = page.locator('.gap-item[data-level="BLOCKED"]');
    const partialGapItems = page.locator('.gap-item[data-level="PARTIAL"]');

    // Must have at least one blocked item visible in this report
    if ((await blockedGapItems.count()) > 0) {
      await expect(blockedGapItems.first()).toBeVisible();
    }

    // Partial items should be hidden when BLOCKED filter is active
    if ((await partialGapItems.count()) > 0) {
      await expect(partialGapItems.first()).not.toBeVisible();
    }
  });

  test("can filter gaps by PARTIAL classification", async ({ page }) => {
    await page.goto("/index.html", { waitUntil: "domcontentloaded" });

    // Click the "PARTIAL" summary card to filter
    const partialCard = page.locator('.card[data-filter="PARTIAL"]');
    await partialCard.click();

    // Filter indicator should show
    const filterIndicator = page.locator("#filter-indicator");
    await expect(filterIndicator).not.toHaveClass(/hidden/);
    await expect(page.locator("#filter-name")).toContainText(/PARTIAL/i);

    // Only PARTIAL gap items should remain visible
    const partialGapItems = page.locator('.gap-item[data-level="PARTIAL"]');
    const blockedGapItems = page.locator('.gap-item[data-level="BLOCKED"]');

    if ((await partialGapItems.count()) > 0) {
      await expect(partialGapItems.first()).toBeVisible();
    }

    // Blocked items should be hidden when PARTIAL filter is active
    if ((await blockedGapItems.count()) > 0) {
      await expect(blockedGapItems.first()).not.toBeVisible();
    }
  });

  test("can filter gaps by MANUAL classification", async ({ page }) => {
    await page.goto("/index.html", { waitUntil: "domcontentloaded" });

    // Click the "MANUAL" summary card to filter (now Custom Implementation)
    const manualCard = page.locator('.card[data-filter="MANUAL"]');
    await manualCard.click();

    // Filter indicator should show
    const filterIndicator = page.locator("#filter-indicator");
    await expect(filterIndicator).not.toHaveClass(/hidden/);
    await expect(page.locator("#filter-name")).toContainText(/MANUAL|Custom/i);

    // Only MANUAL gap items should remain visible
    const manualGapItems = page.locator('.gap-item[data-level="MANUAL"]');

    if ((await manualGapItems.count()) > 0) {
      await expect(manualGapItems.first()).toBeVisible();
    }
  });

  test("can clear filter and show all gaps again", async ({ page }) => {
    await page.goto("/index.html", { waitUntil: "domcontentloaded" });

    // First apply a filter
    await page.locator('.card[data-filter="BLOCKED"]').click();

    const filterIndicator = page.locator("#filter-indicator");
    await expect(filterIndicator).not.toHaveClass(/hidden/);

    // Click clear filter button
    await page.locator("#clear-filter").click();

    // Filter indicator should be hidden again
    await expect(filterIndicator).toHaveClass(/hidden/);

    // All gap items should be visible again
    const partialGapItems = page.locator('.gap-item[data-level="PARTIAL"]');
    const blockedGapItems = page.locator('.gap-item[data-level="BLOCKED"]');

    if ((await partialGapItems.count()) > 0) {
      await expect(partialGapItems.first()).toBeVisible();
    }

    if ((await blockedGapItems.count()) > 0) {
      await expect(blockedGapItems.first()).toBeVisible();
    }
  });

  test("can expand/collapse gap item details", async ({ page }) => {
    await page.goto("/index.html", { waitUntil: "domcontentloaded" });

    // Find first gap item header
    const firstGapHeader = page.locator(".gap-item .gap-header").first();
    await expect(firstGapHeader).toBeVisible();

    // Click to expand/toggle details (if implemented)
    await firstGapHeader.click();

    // This is a basic interaction test - actual behavior depends on app.js implementation
    // Just verify the header is still clickable and visible
    await expect(firstGapHeader).toBeVisible();
  });

  test("optional: export buttons trigger downloads (if implemented)", async ({ page }) => {
    await page.goto("/index.html", { waitUntil: "domcontentloaded" });

    // If your HTML has export buttons, test download functionality
    const exportPdf = page.locator("#export-pdf, button:has-text('Export PDF')");
    const exportCsv = page.locator("#export-csv, button:has-text('Export CSV')");

    if ((await exportPdf.count()) > 0) {
      const downloadPromise = page.waitForEvent("download", { timeout: 5000 }).catch(() => null);
      await exportPdf.click();
      const download = await downloadPromise;

      if (download) {
        expect(download.suggestedFilename()).toMatch(/\.pdf$/i);
      }
    }

    if ((await exportCsv.count()) > 0) {
      const downloadPromise = page.waitForEvent("download", { timeout: 5000 }).catch(() => null);
      await exportCsv.click();
      const download = await downloadPromise;

      if (download) {
        expect(download.suggestedFilename()).toMatch(/\.csv$/i);
      }
    }
  });
});

/**
 * Demo mode test - slower interactions for recording/presentation.
 * Run with: npx playwright test --headed --project=chromium -g "demo mode"
 */
test.describe("HTML report demo mode (presentation)", () => {
  test.use({
    viewport: { width: 1920, height: 1080 },
  });

  test("demo mode: interactive filtering walkthrough", async ({ page }) => {
    // Navigate with a pause for visibility
    await page.goto("/index.html", { waitUntil: "domcontentloaded" });
    await page.waitForTimeout(1000);

    // Scroll to summary cards
    await page.locator(".card").first().scrollIntoViewIfNeeded();
    await page.waitForTimeout(500);

    // Click BLOCKED filter
    await page.locator('.card[data-filter="BLOCKED"]').click();
    await page.waitForTimeout(1500);

    // Scroll through filtered results
    const blockedItems = page.locator('.gap-item[data-level="BLOCKED"]');
    if ((await blockedItems.count()) > 0) {
      await blockedItems.first().scrollIntoViewIfNeeded();
      await page.waitForTimeout(1000);
    }

    // Clear filter
    await page.locator("#clear-filter").click();
    await page.waitForTimeout(1000);

    // Click PARTIAL filter
    await page.locator('.card[data-filter="PARTIAL"]').click();
    await page.waitForTimeout(1500);

    // Clear and show all
    await page.locator("#clear-filter").click();
    await page.waitForTimeout(500);
  });
});
