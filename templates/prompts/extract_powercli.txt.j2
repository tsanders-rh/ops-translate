# PowerCLI Intent Extraction Prompt

You are an expert in VMware PowerCLI automation and infrastructure-as-code migration. Your task is to analyze a PowerCLI script and extract the operational intent into a normalized YAML format.

## Input
You will be provided with a PowerCLI script that provisions or manages VMware virtual machines.

## Task
Extract the operational intent from the PowerCLI script and produce a YAML document that conforms to the Operational Intent Schema (v1).

## Rules
1. **Output YAML only** - No explanations, no markdown code fences, just valid YAML
2. **Conform to schema** - Follow the intent.schema.json structure exactly
3. **Generate description** - Write a 1-3 sentence human-readable summary of what the script does
4. **Extract parameters** - Identify all script parameters from the `param()` block
5. **Detect branching** - Look for environment-specific logic (dev/prod, staging, etc.)
6. **Identify governance** - Look for approval requirements, validation rules, quotas
7. **Map resources** - Extract network, storage, compute specifications
8. **Find metadata** - Identify tags, labels, custom attributes
9. **Day 2 operations** - Infer what operations the script supports beyond provisioning
10. **Document assumptions** - Add an `assumptions` section ONLY if you make non-obvious inferences or decisions that aren't explicitly stated in the code. Omit this section if everything is directly extracted from the source.

## What to Look For

### Parameters
- `param()` block definitions
- `[ValidateSet()]` attributes indicate enum types
- `[int]`, `[string]`, `[bool]` indicate types
- `[Parameter(Mandatory=$true)]` indicates required parameters

### Environment Branching
- `if ($Environment -eq "prod")` patterns
- `ValidateSet("dev", "prod")` on parameters
- Switch statements on environment values

### Network/Storage Profiles
- Variables like `$NetworkName`, `$DatastoreName`
- Conditional selection based on environment
- Hash tables or objects mapping environments to resources

### Tags and Metadata
- `New-TagAssignment` commands
- Hash tables with tag key/value pairs
- Custom attributes: `Set-Annotation`

### Governance
- Approval check patterns (less common in PowerCLI, but note if present)
- Resource validation (CPU/memory limits)
- Cost center or owner tracking

### VM Templates and Images
- `New-VM -Template "TemplateName"` - VM created from a template
- `Import-VApp -Source "path/file.ova"` - OVA/OVF imports
- `Clone-VM -VM "SourceVM"` - Cloning from existing VM
- Template names in variables: `$Template = "RHEL8-Golden"`

When a template/image is detected, include a `vm_source` section:
```yaml
vm_source:
  type: template  # or: ova, ovf, clone, blank
  name: "RHEL8-Golden-Image"
  description: "Red Hat Enterprise Linux 8 golden image template"
```

If no template is specified and VM is created with blank/empty disks, use:
```yaml
vm_source:
  type: blank
```

### Assumptions (when to document)
Only include an `assumptions` section when you make **significant inferences** such as:
- **Inferring behavior** not explicitly coded (e.g., "Assumed day2_operations based on standard VM lifecycle patterns")
- **Setting constraints** not defined in source (e.g., "CPU limit of 32 cores based on typical vSphere constraints - not specified in script")
- **Interpreting ambiguous logic** (e.g., "Network selection logic unclear - assumed prod-network for prod environment")
- **Filling gaps** in incomplete scripts (e.g., "Storage profile not specified - assumed standard datastore")

**DO NOT include assumptions for:**
- Simple extraction of parameters from param() blocks
- Direct mapping of script commands to intent fields
- Obvious naming conventions (e.g., converting VMName to vm_name)
- The fact that intent was extracted by LLM (this is implicit in all outputs)

## Example Input
```powershell
param(
    [Parameter(Mandatory=$true)]
    [string]$VMName,

    [ValidateSet("dev","prod")]
    [string]$Environment = "dev",

    [int]$CPUCount = 2,
    [int]$MemoryGB = 4
)

$Network = if ($Environment -eq "prod") { "prod-net" } else { "dev-net" }
New-VM -Name $VMName -NumCpu $CPUCount -MemoryGB $MemoryGB -NetworkName $Network
New-TagAssignment -Entity $VMName -Tag "env:$Environment"
```

## Example Output
```yaml
schema_version: 1
sources:
  - type: powercli
    file: input/powercli/provision-vm.ps1

intent:
  workflow_name: provision_vm
  description: |
    Provisions a new virtual machine in vSphere with configurable CPU and memory.
    Uses environment-based logic to select the appropriate network (prod-net or dev-net)
    and applies environment tags for tracking.
  workload_type: virtual_machine

  vm_source:
    type: blank

  inputs:
    vm_name:
      type: string
      required: true
      description: Name of the VM to provision
    environment:
      type: enum
      values: [dev, prod]
      required: true
      default: dev
      description: Target environment
    cpu_count:
      type: integer
      required: false
      default: 2
      min: 1
      max: 32
      description: Number of CPU cores
    memory_gb:
      type: integer
      required: false
      default: 4
      min: 1
      max: 256
      description: Memory in GB

  profiles:
    network:
      when: { environment: prod }
      value: prod-net
    network_else: dev-net

  metadata:
    tags:
      - key: env
        value_from: environment

  day2_operations:
    supported: [start, stop]

assumptions:
  - CPU max of 32 and memory max of 256GB set based on typical vSphere constraints (not specified in source)
  - Day 2 operations (start/stop) inferred from VM provisioning context but not explicitly implemented in script
```

## Now Process This Script

{{ script_content }}

Remember: Output valid YAML only. No markdown, no explanations.
