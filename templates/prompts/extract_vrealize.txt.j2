# vRealize Orchestrator Intent Extraction Prompt

You are an expert in VMware vRealize Orchestrator (vRO) workflows and infrastructure automation. Your task is to analyze a vRO workflow export (XML format) and extract the operational intent into a normalized YAML format.

{% if has_nsx %}
## ⚠️ NSX-T INTEGRATION DETECTED

This workflow contains NSX-T API calls. You MUST extract NSX features into the YAML output.

**Detected NSX indicators:**
{{ nsx_indicators }}

**MANDATORY**: Include both `security:` and `integrations:` sections in your YAML output.
{% endif %}

## Input
You will be provided with a vRealize Orchestrator workflow export in XML format.

## Task
Extract the operational intent from the vRO workflow and produce a YAML document that conforms to the Operational Intent Schema (v1).

## Rules
1. **Output YAML only** - No explanations, no markdown code fences, just valid YAML
2. **Conform to schema** - Follow the intent.schema.json structure exactly
3. **Generate description** - Write a 1-3 sentence human-readable summary of what the workflow does
4. **Extract inputs/outputs** - Parse `<inputs>` and `<outputs>` elements
5. **Detect decision points** - Look for `<decision>` elements with branching logic
6. **Identify governance** - Look for approval tasks, user interaction elements
7. **Map resources** - Extract resource allocation patterns from scriptable tasks
8. **Find metadata** - Identify custom properties, tags, attributes
9. **Day 2 operations** - Infer supported operations from workflow purpose
10. **Document assumptions** - Add an `assumptions` section ONLY if you make non-obvious inferences or decisions that aren't explicitly stated in the workflow. Omit this section if everything is directly extracted from the source.

## What to Look For

### Inputs and Outputs
- `<in-binding>` elements define inputs
- `<type>` indicates data type (string, number, boolean, etc.)
- Look for descriptions in `<description>` tags

### Decision Points
- `<decision>` elements with conditional expressions
- Common pattern: environment-based branching
- Look for expressions like `input.environment == "prod"`

### Approval Workflows
- `<item>` elements with `type="task"` often indicate approval steps
- Look for user interaction elements
- Check for workflow names containing "approval" or "review"

### Resource Allocation
- Scriptable task elements often contain JavaScript/Python
- Look for variables like `cpuCount`, `memoryMB`, `networkName`
- Check for custom property assignments

### Tags and Metadata
- Custom properties often stored as key-value pairs
- Look for `customProperties` or similar patterns
- Check for tagging logic in scriptable tasks

### Environment Profiles
- Decision elements that branch on environment
- Different resource pools, networks, or storage per environment
- Look for dev/prod/staging distinctions

### NSX-T Networking and Security
**CRITICAL**: vRO workflows often integrate with NSX-T for networking and security. Look carefully for:

#### NSX API Calls and REST Endpoints
- REST calls to NSX Manager (endpoints like `/api/v1/`, `/policy/api/v1/`)
- REST operations: `POST`, `PUT`, `PATCH` to NSX endpoints
- Look for `RESTHostManager.createHost("nsx-api")` or similar NSX REST client creation

#### NSX Security Groups
- Variables or API paths containing: `security_group`, `ns-groups`, `NSGroup`
- Membership assignment operations
- Patterns like `SG-{ENV}-{TIER}` for security group names

#### NSX Distributed Firewall
- Firewall rule creation or modification
- API paths containing: `/firewall/sections`, `/firewall/rules`
- Rule definitions with sources, destinations, services, actions (ALLOW/DENY)
- Tier-based isolation rules (web → app → db)

#### NSX Segments (Overlay Networks)
- Segment creation API calls (`/infra/segments`)
- Overlay network configuration
- VLAN/subnet assignments
- Transport zone references

#### NSX Load Balancers
- Load balancer pool creation (`/infra/lb-pools`)
- Virtual server configuration (`/infra/lb-virtual-servers`)
- Member pool definitions with backend IPs/ports
- Health monitor configurations

**When NSX features are detected**, structure them in the YAML as:

```yaml
security:
  network_segmentation:
    enabled: true
    security_group_pattern: "pattern-from-workflow"
  firewall_rules:
    tier_name:
      when: { condition }
      rules:
        - name: rule-name
          direction: IN/OUT
          action: ALLOW/DENY
          sources: [...]
          destinations: [...]
          services: [...]

integrations:
  - type: nsx-t
    endpoint: nsx-manager-hostname
    operations:
      - security_group_membership
      - firewall_rule_creation
      - segment_creation
      - load_balancer_configuration
```

### Assumptions (when to document)
Only include an `assumptions` section when you make **significant inferences** such as:
- **Interpreting complex logic** (e.g., "Approval workflow inferred from decision element - actual approval mechanism not specified")
- **Inferring from workflow name/context** (e.g., "Day 2 operations assumed from workflow name 'VM Lifecycle Management' but not explicitly implemented")
- **Resolving ambiguity** (e.g., "Multiple network selection paths - assumed prod-network for production based on decision logic")
- **Setting constraints** not defined (e.g., "Memory limits not specified - set to 256GB based on common vRO patterns")
- **Extracting from nested sub-workflows** (e.g., "Storage configuration delegated to sub-workflow - assumed standard profiles")

**DO NOT include assumptions for:**
- Direct extraction of inputs/outputs from XML elements
- Straightforward decision logic mapping
- Simple parameter type conversions
- The fact that intent was extracted by LLM (this is implicit in all outputs)

## Example Input (simplified)
```xml
<workflow>
  <display-name>Provision VM with NSX Firewall</display-name>
  <input>
    <param name="vmName" type="string"/>
    <param name="environment" type="string"/>
    <param name="appTier" type="string"/>
    <param name="cpuCount" type="number"/>
    <param name="memoryGB" type="number"/>
  </input>
  <workflow-item name="approvalCheck" type="decision">
    <expression>environment == "prod"</expression>
  </workflow-item>
  <workflow-item name="assignSecurityGroup" type="task">
    <script>
      securityGroup = "SG-" + environment.toUpperCase() + "-" + appTier.toUpperCase();
      var restHost = RESTHostManager.createHost("nsx-api");
      var request = restHost.createRequest("POST", "/api/v1/ns-groups/" + securityGroup + "/members", "");
      request.execute(JSON.stringify({resource_type: "VirtualMachine", external_id: vm.id}));
    </script>
  </workflow-item>
  <workflow-item name="createFirewallRule" type="task">
    <script>
      var rule = {
        display_name: vmName + "-allow-http",
        action: "ALLOW",
        services: [{service: "HTTP"}]
      };
      var request = restHost.createRequest("POST", "/api/v1/firewall/sections/web-tier/rules", "");
      request.execute(JSON.stringify(rule));
    </script>
  </workflow-item>
</workflow>
```

## Example Output
```yaml
schema_version: 1
sources:
  - type: vrealize
    file: input/vrealize/provision.workflow.xml

intent:
  workflow_name: provision_vm_with_nsx_firewall
  description: |
    Provisions a virtual machine in vSphere with NSX-T security integration.
    Assigns VM to tier-based security groups and creates distributed firewall
    rules based on application tier. Includes approval workflow for production.
  workload_type: virtual_machine

  inputs:
    vm_name:
      type: string
      required: true
      description: Name of the VM
    environment:
      type: enum
      values: [dev, prod]
      required: true
      description: Target environment
    app_tier:
      type: enum
      values: [web, app, db]
      required: true
      description: Application tier for security segmentation
    cpu_count:
      type: integer
      required: true
      min: 1
      max: 32
      description: Number of CPUs
    memory_gb:
      type: integer
      required: true
      min: 1
      max: 256
      description: Memory in GB

  governance:
    approval:
      required_when:
        environment: prod

  security:
    network_segmentation:
      enabled: true
      security_group_pattern: "SG-{{ environment | upper }}-{{ app_tier | upper }}"
    firewall_rules:
      web_tier:
        when: { app_tier: web }
        rules:
          - name: "{{ vm_name }}-allow-http"
            direction: IN
            action: ALLOW
            sources: ["0.0.0.0/0"]
            services: [HTTP]

  integrations:
    - type: nsx-t
      endpoint: nsx-manager.acme.internal
      operations:
        - security_group_membership
        - firewall_rule_creation

  day2_operations:
    supported: [start, stop, reconfigure]

assumptions:
  - Approval mechanism inferred from decision element but actual approval task/integration not specified in workflow
  - Firewall rule extracted from scriptable task - additional rules for app and db tiers likely exist in similar pattern
```

## Important Notes
- vRO workflows often have complex nested logic - focus on extracting the core intent
- Scriptable tasks may contain JavaScript or other languages - extract the operational meaning, not implementation
- If the workflow contains sub-workflows, note them but focus on the top-level intent
- Some information may be in comments or description fields - use these to clarify intent
- **NSX Integration is Critical**: Many enterprise vRO workflows integrate with NSX-T for networking and security. Carefully examine scriptable tasks for REST API calls to NSX Manager. These features have significant migration implications and must be captured in the `security` and `integrations` sections.

## Now Process This Workflow

{{ workflow_content }}

Remember: Output valid YAML only. No markdown, no explanations.

**CRITICAL REMINDER**: If you detect ANY NSX REST API calls (RESTHostManager, /api/v1/, /policy/api/v1/), you MUST include `security` and `integrations` sections in the YAML output! Do not skip NSX features!
